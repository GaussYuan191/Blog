{"title":"详解 js 继承","slug":"详解js继承","date":"2022-02-08","updated":"2022-02-08","comments":true,"path":"api/posts/31746.json","excerpt":"<p></p>","cover":"/gallery/js-extend-01.png","covers":["/gallery/js-extend-01.png"],"content":"<p><img src=\"/gallery/js-extend-01.png\" alt=\"\"></p><a id=\"more\"></a><h1 id=\" 预备知识 \"><a class=\"headerlink\"href=\"# 预备知识 \"></a>预备知识 </h1><h1 id=\"1、构造函数属性 \"><a class=\"headerlink\"href=\"#1、构造函数属性 \"></a>1、构造函数属性</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name; <span class=\"comment\">// 实例基本的属性（该属性，强调私有，不共享）</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.arr = [<span class=\"number\">1</span>] <span class=\"comment\">// 实例引用属性（该属性，强调私有，不共享）</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实例引用属性吗，强调共享</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"2、什么是原型对象 \"><a class=\"headerlink\"href=\"#2、什么是原型对象 \"></a>2、什么是原型对象</h2><p> 简单来说，每个函数都有 prototype 属性，它就是原型对象，通过函数实例化出来的对象有个 **<strong>proto</strong>** 属性，指向原型对象 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> A()</span><br><span class=\"line\">a.__proto__ == A.prototype</span><br><span class=\"line\"><span class=\"comment\">// prototype 的结构如下</span></span><br><span class=\"line\">A.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: A</span><br><span class=\"line\">    ... 其他属性和方法</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"3、原型链 \"><a class=\"headerlink\"href=\"#3、原型链 \"></a>3、原型链</h2><p> 每个对象都有原型，当访问这个变量的时候，这个变量不存在就访问他的原型，就这样一直循环下去就产生了原型链！</p><p><img src=\"/gallery/js-extend-02.png\"alt=\"\"></p><p>首先，fn 的构造函数是 Foo()。所以：<br>fn._ _ proto _ <em>=== Foo.prototype<br>又因为 Foo.prototype 是一个普通的对象，它的构造函数是 Object，所以：<br>Foo.prototype.</em> _ proto _ _=== Object.prototype<br>通过上面的代码，我们知道这个 toString()方法是在 Object.prototype 里面的，当调用这个对象的本身并不存在的方法时，它会一层一层地往上去找，一直到 null 为止。</p><p>所以当 fn 调用 toString()时，JS 发现 fn 中没有这个方法，于是它就去 Foo.prototype 中去找，发现还是没有这个方法，然后就去 Object.prototype 中去找，找到了，就调用 Object.prototype 中的 toString()方法。</p><p>这就是原型链，fn 能够调用 Object.prototype 中的方法正是因为存在原型链的机制。</p><p>另外，在使用原型的时候，一般推荐将需要扩展的方法写在构造函数的 prototype 属性中，避免写在_ _ proto _ _属性里面。</p><h2 id=\"4、原型对象的作用\"><a class=\"headerlink\" href=\"#4、原型对象的作用\"></a>4、原型对象的作用 </h2><p> 原型对象的用途是为每个实例对象存储共享的方法和属性，它仅仅是一个普通的对象而已。并且所有的实例是共享同一个原型对象, 因此有别于实例方法或属性，原型对象仅一份。实例对象有很多份且实例属性和⽅法是独⽴的。在构造函数中：为了属性 (实例基本属性) 的私有性、以及⽅法 (实例引⽤属性) 的复⽤、共享。我们提倡：</p><ul><li>将属性封装在构造函数中 </li><li> 将方法定义在原型对象上</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name; <span class=\"comment\">// (该属性，强调私有，不共享)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义在原型对象上的⽅法 (强调复⽤，需要共享)</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 不推荐的写法：[原因](https://blog.csdn.net/kkkkkxiaofei/article/details/46474303)</span></span><br><span class=\"line\">A.prototype = &#123;</span><br><span class=\"line\">  say: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","url":"/posts/31746/","min2read":2,"word4post":677,"prev_post":null,"next_post":{"title":"React 的生命周期验证","url":"/posts/36377/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\" 预备知识 \" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">预备知识 </span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"1、构造函数属性 \" href = \"#\"><span class=\"toc-number\">2.</span> <span class=\"toc-text\">1、构造函数属性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"2、什么是原型对象 \" href = \"#\"><span class=\"toc-number\">2.1.</span> <span class=\"toc-text\">2、什么是原型对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"3、原型链 \" href = \"#\"><span class=\"toc-number\">2.2.</span> <span class=\"toc-text\">3、原型链</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"4、原型对象的作用\" href = \"#\"><span class=\"toc-number\">2.3.</span> <span class=\"toc-text\">4、原型对象的作用 </span></a></li></ol></li></ol>","categories":[{"name":"继承","path":"api/categories/继承.json","url":"/categories/继承/"}],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json","url":"/tags/JavaScript/"}]}